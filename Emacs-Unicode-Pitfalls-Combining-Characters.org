* 组合字符（Combining Characters）

有些Unicode字符定义为组合字符。这些字符的作用是修改它前面的非组合字符，典型作用是加重或者变音标记。

举个例子，单词“naïve”可以写作这6个字符"nai\u0308ve"。第4个字符U+0308（组合分音符）就是一个组合字符，用来将“i” (U+0069 LATIN SMALL LETTER I)变成一个变音字符。

通常的加重字符也有它自己的编码值，叫做预组合字符（precomposed characters），包括ï (U+00EF LATIN SMALL LETTER I WITH DIAERESIS)。所以“naïve”也可以写作这5个字符"na\u00EFve"。

** 归一化（Normalization）

那么比较两个两个不同表示的字符会结果如何呢？

不相等。

#+BEGIN_SRC emacs-lisp
  (string= "nai\u0308ve" "na\u00EFve")
  ;; => nil
#+END_SRC

为了应对这种情况，Unicode标准定义了4种不同的归一化。其中最重要的两种是NFC（组合）和NFD（分解）。前者尽可能地使用预组合字符而后者尽可能地将其拆分。ucs-normalize-NFC-string和ucs-normalize-NFD-string函数用来实现这两个操作。

*陷阱提示#1： 务必先进行归一化再进行字符串比较。*  不管使用哪种归一化（NFD要稍微快一点），但需要一致。不幸的是，当你比较复杂的多字符串时依然可能产生奇怪的结果。

#+BEGIN_SRC emacs-lisp
  (string= (ucs-normalize-NFD-string "nai\u0308ve")
           (ucs-normalize-NFD-string "na\u00EFve"))
  ;; => t
#+END_SRC

用Emacs自带的函数比较会失败，它在使用intern函数前不会做归一化，也许这是个错误。这意味着你可以使用相同的名称（intern转换的canonical symbol）来定义不同的变量和函数。

#+BEGIN_SRC emacs-lisp
  (eq (intern "nai\u0308ve")
      (intern "na\u00EFve"))
  ;; => nil

  (defun print-résumé ()
    "NFC-normalized form."
    (print "I'm going to sabotage your team."))

  (defun print-résumé ()
    "NFD-normalized form."
    (print "I'd be a great asset to your team."))

  (print-résumé)
  ;; => "I'm going to sabotage your team."
#+END_SRC

** 字符串宽度

有三种方法可以用来计算多字节文本的数量，通常它们的值相同，但是在有些情况下它们却各不不同。

  * 长度： 字符个数，包括组合字符
  * 字节数： 用UTF-8编码的字节数
  * 宽度： 占当前缓冲区的列数

大多数时候，一个字符就是一列（一个字符的宽度）。有一些字符，比如组合字符，不占用宽度。一些亚洲国家字符占两列，比如(U+4000, 䀀)。Tab占用tab-width列，通常是8。

通常来说，不管使用NFD或者NFC，字符串的宽度是一样的。然而，由于bug和对Unicode的支持不完整，这个说法不是完全正确。例如，有些组合字符，如U+20DD, ⃝  在Emacs中或者其他应用程序中无法正确地组合。

*陷阱提示#2： 当展示一个buffer时，务必使用宽度而不是长度来计算文本。*  宽度通过string-width函数来计算，当展示buffer中的表格的时候会被调用。每列中适当的字符个数要根据是什么字符而定。

幸运的是，有次碰巧通过[[http://nullprogram.com/blog/2013/09/04/][Elfeed]]得到了正确结果，因为我使用了format函数来展示。如希望地那样，%s指示符用来操作宽度。然而有个副作用：很多格式化的输出会根据当前buffer而改变！ *陷阱提示#3： 使用format函数时务必注意当前buffer。*

#+BEGIN_SRC emacs-lisp
  (let ((tab-width 4))
    (length (format "%.6s" "\t")))
  ;; => 1

  (let ((tab-width 8))
    (length (format "%.6s" "\t")))
  ;; => 0
#+END_SRC

** 字符串反转

加入要将一个多字节字符串反转。很简单，对吗？

#+BEGIN_SRC emacs-lisp
  (defun reverse-string (string)
    (concat (reverse (string-to-list string))))

  (reverse-string "abc")
  ;; => "cba"
#+END_SRC

错了！组合字符经反转会对之前它右边的字符进行修改而产生错误。

#+BEGIN_SRC emacs-lisp
  (reverse-string "nai\u0308ve")
  ;; => "ev̈ian"
#+END_SRC

*Pitfall #4: [[https://github.com/mathiasbynens/esrever][Unicode字符串反转务必小心]]。* [[http://rosettacode.org/wiki/Reverse_a_string][Rosetta Code]] 页面罗列了许多错误的案例， [[http://nullprogram.com/blog/2012/11/15/][我个人也出过错]] 。之后我[[https://github.com/magnars/s.el/pull/58][提交了一个s.el的补丁]] 来修正Unicode的s-reverse函数。
如果这个能被接受，你就不用再担心这个了。

** 正则表达式

正则表达式基于编码值。组合字符单独计算，匹配会根据字符如何组合可能不不同。为了避免这种情况，你需要在做某些正则匹配之前进行NFC归一化。

#+BEGIN_SRC emacs-lisp
  ;; Like string= from before:
  (string-match-p  "na\u00EFve" "nai\u0308ve")
  ;; => nil

  ;; Use NFC normilization
  (string-match-p (ucs-normalize-NFC-string "na\u00EFve") 
                  (ucs-normalize-NFC-string "nai\u0308ve"))
  ;; => 0

  ;; The . only matches part of the composition
  (string-match-p "na.ve" "nai\u0308ve")
  ;; => nil
  
  ;; .. matches i and the composition character
  (string-match-p "na..ve" "nai\u0308ve")
  ;; => 0

#+END_SRC

*陷阱提示#5： 使用正则表达式时务必注意组合字符，且优先选择NFC归一化。*

另一个潜在的问题是范围，尽管这不太常见。字符的范围可以用中括号来表达，比如[a-zA-Z]。如果范围以分解的组合字符开始或结束，将得不到正确的结果，因为组合字符部分会被正则表达式引擎单独处理。

#+BEGIN_SRC emacs-lisp
  (defvar match-weird "[\u00E0-\u00F6]+")

  (string-match-p match-weird "áâãäå")
  ;; => 0  (successful match)

  (string-match-p (ucs-normalize-NFD-string match-weird) "áâãäå")
  ;; => nil
#+END_SRC

在审查一些不受信任的输入时将所有这些牢记于心是非常重要的，比如使用Emacs作为Web server，攻击者可能使用非归一化或奇怪的字符串来绕开过滤器。
