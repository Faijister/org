* Emacs和UTF-8

*在Emacs内部所有的文本都用UTF-8格式存储* ，这是个非常明智的选择！当Emacs输出文本，比如写到文件或者传到另一个进程，Emacs会自动根据文件或进程所配置的编码系统来对文本进行编码。当读取一个文件或者进程的文本时，Emacs要么它将其转换为UTF-8编码格式，要么保持原始字节。

关于这点在Emacs中有2种模式：单字节和多字节。单字节strings/buffers就是原始字节，它们满足常量时间O(1)访问但是进能保存单字节值[[http://nullprogram.com/blog/2014/01/04/][byte-code compiler outputs unibyte strings]]。

多字节strings/buffers保存UTF-8编码的编码值。字符访问时间复杂读是O(n)因为需要遍历一边string/buffer来计算字符个数。

实际的编码很少关心，因为没有太多方法（和需要）来直接访问。当文本输入或输出时，Emacs会自动将文本编码格式按需进行转换，所以不需要关心内部的编码。如果你 /确实/ 想知道，你可以用string-as-unibyte来得到以字节表示的string。

#+BEGIN_SRC emacs-lisp
  (string-as-unibyte "π")
  ;; => "\317\200"
#+END_SRC

This can be reversed with string-as-multibyte), to change a unibyte string
holding UTF-8 encoded text back into a multibyte string. Note that these
functions are different than string-to-unibyte and string-to-multibyte, which
will attempt a conversion rather than preserving the raw bytes.

The length and buffer-size functions always count characters in multibyte and
bytes in unibyte. Being UTF-8, there are no surrogate pairs to worry about
here. The string-bytes and position-bytes functions return byte information
for both multibyte and unibyte.

To specify a Unicode character in a string literal without using the character
directly, use \uXXXX. The XXXX is the hexadecimal code point for the character
and is always 4 digits long. For characters outside the BMP, which won’t fit
in four digits, use a capital U with eight digits: \UXXXXXXXX.

#+BEGIN_SRC emacs-lisp
  "\u03C0"
  ;; => "π"

  "\U0001F4A9"
  ;; => "💩"  (PILE OF POO)
#+END_SRC

Finally, Emacs extends Unicode with 256 additional “characters” representing
raw bytes. This allows raw bytes to be embedded distinctly within UTF-8
sequences. For example, it’s used to distinguish the code point U+0041 from
the raw byte #x41. As far as I can tell, this isn’t used very often.
