#+URL: http://nullprogram.com/blog/2014/06/13/
#+TITLE: Emacs UnicodeÈô∑Èò±

GNU EmacsÁöÑÂèëÂ∏ÉË¶ÅÊØîUnicodeÊó©7Âπ¥„ÄÇEmacsÂ≠òÂú®‰ª•ÂêéÊòØÂú®Áõ∏ÂØπËæÉÊôöÁöÑÊó∂ÂÄôÊâçÂä†ÂÖ•‰∫ÜÂØπUnicodeÁöÑÊîØÊåÅÔºåËøôÊÑèÂë≥ÁùÄÂú®EmacsÁöÑÂéÜÂè≤‰∏≠Ôºå‰∏çÊîØÊåÅUnicodeÁöÑÊó∂Èó¥ÊÆµÔºà16Âπ¥ÔºâÊØîÊîØÊåÅUnicodeÁöÑÊó∂Èó¥ÊÆµÔºà14Âπ¥ÔºâËøòË¶ÅÈïø„ÄåÊ≥®ÔºöÊñáÁ´†ÂèëË°®‰∫é2014Âπ¥„Äç„ÄÇÂ∞ΩÁÆ°Â¶ÇÊ≠§ÔºåEmacsÂØπUnicodeÁöÑÊîØÊåÅÂçÅÂàÜÂá∫Ëâ≤ÔºåËÆ©‰∫∫ÊÑüËßâ‰ºº‰πéÂÆÉ‰∏ÄÁõ¥ÈÉΩÊîØÊåÅUnicode„ÄÇ
# EmacsÈ¶ñÊ¨°ÂèëÂ∏É‰∫é1985Âπ¥3Êúà
# UnicodeÈ¶ñÊ¨°ÂèëÂ∏É‰∫é1992Âπ¥6Êúà
ÁÑ∂ËÄå,Áî±‰∫éUnicodeÁöÑÁõÆÊ†áÊòØË¶ÅÊ∂µÁõñÊâÄÊúâÂ∑≤Áü•ÁöÑ‰∫∫Á±ªËØ≠Ë®ÄÂèäÂÖ∂ÂêÑÂºèÂêÑÊ†∑ÁöÑÁªÜÊûùÊú´ËäÇ,ÁªìÊûúËá™ÁÑ∂‰ºöÂ≠òÂú®‰∏Ä‰∫õÈô∑Èò±ÂíåÈóÆÈ¢ò„ÄÇÂ¶ÇÊûú‰ªÖ‰Ωú‰∏∫‰∏Ä‰∏™Emacs‰ΩøÁî®ËÄÖÁöÑËØùÔºå‰Ω†ÂèØËÉΩ‰∏çÂ§™‰ºöÂõ†Ê≠§ËÄåÂèóÂà∞ÂΩ±Âìç„ÄÇ‰ΩÜÂ¶ÇÊûú‰Ωú‰∏∫‰∏Ä‰∏™Êâ©Â±ïÔºàÊèí‰ª∂ÔºâÁöÑÂºÄÂèëËÄÖÔºå‰Ω†ÂæàÂèØËÉΩ‰ºöÂú®Â§ÑÁêÜEmacsÁöÑstringsÂíåbuffersÊó∂ÈÅáÂà∞È∫ªÁÉ¶ÔºåËøô‰∏§‰∏™ÈÉΩÊòØÂü∫‰∫éÂ≠óÁ¨¶ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇ

Âú®ËøôÁØáÊñáÁ´†‰∏≠ÔºåÊàëÂ∞ÜÂàÜ‰∫´Elisp‰∏≠UnicodeÂ∏¶ÁªôÊàë‰ª¨ÁöÑ‚ÄúÊÉäÂñú‚Äù„ÄÇÊàëËá™Â∑±Â∞±ÊõæÈÅáÂà∞ËøáÂ•ΩÂá†‰∏™Ôºå‰∫ãÂÆû‰∏äÔºåÂÜôËøôÁØáÊñáÁ´†ËøòËÆ©ÊàëÂú®Ëá™Â∑±ÁöÑÊâ©Â±ïÁ®ãÂ∫è‰∏≠ÂèëÁé∞‰∫ÜÂ•ΩÂá†‰∏™ÁºñÁ†ÅÊñπÈù¢ÁöÑÂ∞èbug„ÄÇËøô‰∫õÁº∫Èô∑ÈÉΩ‰∏çÊòØEmcasÁöÑÈîôÔºåÂÆÉ‰ª¨Âè™ÊòØËá™ÁÑ∂ËØ≠Ë®ÄÁöÑÂ§çÊùÇÊÄßÂØºËá¥ÁöÑÁªìÊûú„ÄÇ

* UnicodeÂíåÁºñÁ†ÅÂÄºÔºàCode PointÔºâ

È¶ñÂÖàÔºåÁΩë‰∏äÊúâÈùûÂ∏∏Â•ΩÁöÑËµÑÊñôÊù•Â≠¶‰π†UnicodeÔºåÊàëÊé®Ëçê‰ªé[[http://www.cl.cam.ac.uk/~mgk25/unicode.html][UTF-8 and Unicode FAQ for Unix/Linux]]ÂºÄÂßã„ÄÇÊàëÊ≤°ÊúâÁêÜÁî±Âú®ËøôÈáåÈáçÂ§çÊâÄÊúâÁöÑ‰ø°ÊÅØÔºå‰ΩÜÊòØÊàë‰ºöÂ∞ùËØïÂø´ÈÄüÂú∞ÊÄªÁªì‰∏Ä‰∏ã„ÄÇUnicodeÂ∞Ü‰∏Ä‰∏™ÁºñÁ†ÅÂÄºÔºàÊï¥Êï∞ÔºâÊò†Â∞ÑÂà∞Êüê‰∏™ÂÖ∑‰ΩìÁöÑÂ≠óÁ¨¶ÔºåÂπ∂Â∏¶‰∏Ä‰∏™Ê†áÂáÜÁöÑÂêçÂ≠ó„ÄÇÂú®ÂÜôËøôÁØáÊñáÁ´†ÁöÑÊó∂ÂÄôUnicodeÂÆö‰πâ‰∫ÜË∂ÖËøá11‰∏á‰∏™ÁöÑÂ≠óÁ¨¶„ÄÇ‰∏∫‰∫ÜÂêéÂêëÂÖºÂÆπÊÄßÔºåÂâç128‰∏™ÁºñÁ†ÅÂÄºÊò†Â∞ÑÂà∞ASCIIÁ†Å„ÄÇËøô‰∏™Ë∂ãÂäø‰πüË¢´ÂÖ∂‰ªñÁöÑÂ≠óÁ¨¶ÁºñÁ†ÅÊ†áÂáÜÊé•ÂèóÔºåÊØîÂ¶ÇLatin-1„ÄÇ

Âú®Emacs‰∏≠ÔºåUnicodeÂ≠óÁ¨¶‰ΩøÁî®C-x 8 RETÔºàinsert-charÔºâËæìÂÖ•Âà∞buffer‰∏≠„ÄÇ‰Ω†Êó¢ÂèØ‰ª•ËæìÂÖ•Ê†áÂáÜÁöÑÂ≠óÁ¨¶ÂêçÁß∞ÔºàÊØîÂ¶ÇÔºöœÄÊòØ‚ÄúGREEK SMALL LETTER PI‚ÄùÔºâÔºå‰πüÂèØ‰ª•Áõ¥Êé•ËæìÂÖ•ÂçÅÂÖ≠ËøõÂà∂ÁöÑÁºñÁ†ÅÂÄº„ÄÇÂú®Emacs‰πãÂ§ñÁöÑÂÖ∂‰ªñÂ∫îÁî®Á®ãÂ∫è‰∏≠Â¶Ç‰ΩïËæìÂÖ•ÊòØË¶ÅÁúãÊÉÖÂÜµÁöÑÔºå‰ΩÜÊòØÂ∞±ÊàëÂÖ≥ÂøÉÁöÑÂ∫îÁî®Êù•ËØ¥C-S-uÂä†‰∏äÂçÅÂÖ≠ËøõÂà∂ÁöÑÁºñÁ†ÅÂÄºÈÉΩÊòØÂèØ‰ª•ÁöÑ„ÄÇ

** ÁºñÁ†Å

UnicodeÊ†áÂáÜ‰πüÊèèËø∞‰∫ÜÂá†ÁßçÊñπÊ≥ïÊù•Â∞ÜÁºñÁ†ÅÂÄºÂ∫èÂàóËΩ¨ÊàêÂ≠óËäÇÂ∫èÂàó„ÄÇÂæàÊòéÊòæÔºå11‰∏á‰∏™Â≠óÁ¨¶Êó†Ê≥ïÁî®‰∏Ä‰∏™Â≠óËäÇÊù•ÁºñÁ†ÅÔºåÊâÄ‰ª•Â∞±Êúâ‰∫ÜÂ§öÂ≠óËäÇÁºñÁ†ÅÊ†ºÂºè„ÄÇÊúÄÊµÅË°åÁöÑ‰∏§ÁßçUnicodeÁºñÁ†ÅÊ†ºÂºèÂ∫îËØ•ÊòØUTF-8ÂíåUTF-16„ÄÇ

UTF-8ËÆæËÆ°‰πãÂàùÂ∞±ÊòØË¶ÅÂêéÂêëÂÖºÂÆπÂ∑≤Â≠òÂú®ÁöÑASCIIÁºñÁ†Å„ÄÅUnixÁ≥ªÁªü‰ª•ÂèäCËØ≠Ë®ÄAPIÔºà‰ª•null‰Ωú‰∏∫ÁªàÊ≠¢Á¨¶ÁöÑCÂ≠óÁ¨¶‰∏≤Ôºâ„ÄÇÂâç128‰∏™ÁºñÁ†ÅÂÄºÁõ¥Êé•ÁºñÁ†Å‰∏∫ÂçïÂ≠óËäÇÔºåÂÖ∂‰ªñÂ≠óÁ¨¶Áî®2Âà∞6ÁöÑÂ≠óËäÇÊù•ÁºñÁ†ÅÔºåÊâÄÊúâÂ≠óËäÇÁöÑÊúÄÈ´òÊØîÁâπËÆæÁΩÆ‰∏∫1ÔºåËøôÊ†∑ÊâÄÊúâÂ§öÂ≠óËäÇÁöÑÂ≠óÁ¨¶ÈÉΩ‰∏ç‰ºöË¢´Ëß£Èáä‰∏∫ASCIIÂ≠óÁ¨¶Ôºå‰πü‰∏ç‰ºöÂ≠òÂú®nullÔºà0Ôºâ„ÄÇËøôÊ†∑CËØ≠Ë®ÄÂÜôÁöÑÁ®ãÂ∫èÂíåAPIÂ∞±ËÉΩÂ§ü‰∏çÊîπÂèòÊàñËÄÖÂÅöÁ®çÂæÆË∞ÉÊï¥Â∞±ËÉΩÂ§ÑÁêÜUTF-8ÁöÑÂ≠óÁ¨¶‰∏≤‰∫Ü„ÄÇÊúÄÈáçË¶ÅÁöÑÊòØÔºåÊØè‰∏Ä‰∏™ASCIIÁ†ÅÁºñÁ†ÅÁöÑÊñá‰ª∂Ëá™Âä®ÂèØ‰ª•ËΩ¨Êç¢‰∏∫UTF-8ÁºñÁ†ÅÁöÑÊñá‰ª∂„ÄÇ

UTF-16Áî®2‰∏™Â≠óËäÇÊù•ÁºñÁ†ÅÂü∫Êú¨Â§öÊñáÁßçÂπ≥Èù¢ÔºàÁ¨¨Èõ∂Âπ≥Èù¢ÔºåBasic Multilingual Plane - BMPÔºâ‰∏≠ÁöÑÂ≠óÁ¨¶ÔºåÁîöËá≥ÂéüÊú¨ÁöÑASCIIÂ≠óÁ¨¶‰πüÁî®2‰∏™Â≠óËäÇÔºà16ÊØîÁâπÔºâ„ÄÇÁ¨¨Èõ∂Âπ≥Èù¢Âü∫Êú¨‰∏äÊ∂µÁõñ‰∫ÜÊâÄÊúâÁé∞‰ª£ËØ≠Ë®Ä‰∏≠ÂÆûÈôÖ‰ΩøÁî®Âà∞ÁöÑÊâÄÊúâÂ≠óÁ¨¶„ÄÇÁÑ∂ËÄå,UTF-16Âç¥‰∏çÂåÖÊã¨ËæÖÂä©ÔºàÊòü‰ΩìÔºâÂπ≥Èù¢‰∏≠ÈáçË¶ÅÁöÑ‰æãÂ¶Ç[[http://www.fileformat.info/info/unicode/char/1f379/index.htm][TROPICAL DRINK]]ÊàñËÄÖ[[http://www.fileformat.info/info/unicode/char/1F4A9/index.htm][PILE OF POO]]Â≠óÁ¨¶„ÄÇÂ¶ÇÊûú‰Ω†ÈúÄË¶ÅÂú®UTF-16‰∏≠Áî®Ëøô‰∫õÂ≠óÁ¨¶Â∞ÜÂá∫Áé∞ÈóÆÈ¢òÔºöË∂ÖËøáÁ¨¨Èõ∂Âπ≥Èù¢ÁöÑÂ≠óÁ¨¶‰∏çËÉΩË¢´ÊîæÂú®2‰∏™Â≠óËäÇ‰∏≠„ÄÇ‰∏∫‰∫ÜËÉΩÂÆπÁ∫≥Ëøô‰∫õÂ≠óÁ¨¶ÔºåUTF-16‰ΩøÁî®‰ª£ÁêÜÂØπÔºàsurrogate pairsÔºâÔºöËøô‰∫õÂ≠óÁ¨¶‰ºöÁî®‰∏ÄÂØπ2Â≠óËäÇÂçïÂÖÉÊù•ÁºñÁ†Å„ÄÇ

Áî±‰∫éÊúÄÂêé‰∏ÄÁÇπ, UTF-16Áõ∏ÂØπ‰∫éUTF-8Ê≤°ÊúâÂÆûÁî®‰∏äÁöÑ‰ºòÂäø„ÄÇÂÆÉÁöÑ[[http://www.utf8everywhere.org/][Â≠òÂú®ÂèØËÉΩÊòØ‰∏Ä‰∏™Â∑®Â§ßÁöÑÈîôËØØ]]„ÄÇÁî±‰∫é‰ª£ÁêÜÂØπÁöÑÂ≠òÂú®Ôºå‰Ω†Êó†Ê≥ïÁî®ÊÅíÂÆöÊó∂Èó¥ÁÆóÊ≥ïÂéªÊü•ÊâæÔºåËÄå‰∏î‰∏çËÉΩÂêéÂêëÂÖºÂÆπ‰πü‰∏çËÉΩÂ≠òÂÇ®Âú®‰ª•nullÁªìÂ∞æÁöÑÂ≠óÁ¨¶‰∏≤‰∏≠„ÄÇÂú®JavaÂíåJavaScript‰∏≠ÔºåÂÆÉ‰ºöÂØºËá¥‰∏Ä‰∫õÂ≠óÁ¨¶‰∏≤‚ÄúÈïøÂ∫¶‚ÄùÂíåÂ≠óÁ¨¶„ÄÅÁºñÁ†ÅÂÄºÁîöËá≥Â≠óËäÇÊï∞‰∏ç‰∏ÄËá≥ÁöÑÁ™òÂ¢É„ÄÇÊúÄÁ≥üÁ≥ïÁöÑÊòØÔºåÂÆÉ‰ºöÂØºËá¥[[https://speakerdeck.com/mathiasbynens/hacking-with-unicode?slide=114][‰∏•ÈáçÁöÑÂÆâÂÖ®ÈöêÊÇ£]]„ÄÇÊñ∞ÁöÑÂ∫îÁî®Á®ãÂ∫èÂ∫îËØ•Â∞ΩÂèØËÉΩÂú∞ÈÅøÂÖçËøô‰∫õÈóÆÈ¢ò„ÄÇ

* EmacsÂíåUTF-8

*Âú®EmacsÂÜÖÈÉ®ÊâÄÊúâÁöÑÊñáÊú¨ÈÉΩÁî®UTF-8Ê†ºÂºèÂ≠òÂÇ®*. This was an excellent choice! When
text leaves Emacs, such as writing to a file or to a process, Emacs
automatically converts it to the coding system configured for that particular
file or process. When it accepts text from a file or process, it either
converts it to UTF-8 or preserves it as raw bytes.

There are two modes for this in Emacs: unibyte and multibyte. Unibyte strings/
buffers are just raw bytes. They have constant access O(1) time but can only
hold single-byte values. The [[http://nullprogram.com/blog/2014/01/04/][byte-code compiler outputs unibyte strings]].

Multibyte strings/buffers hold UTF-8 encoded code points. Character access is
O(n) because the string/buffer has to be scanned to count characters.

The actual encoding is rarely relevant because there‚Äôs little way (and need)
to access it directly. Emacs automatically converts text as needed when it
leaves Emacs and arrives in Emacs, so there‚Äôs no need to know the internal
encoding. If you really want to see it anyway, you can use string-as-unibyte
to get a copy of a string with the exact same bytes, but as a byte-string.

#+BEGIN_SRC emacs-lisp
  (string-as-unibyte "œÄ")
  ;; => "\317\200"
#+END_SRC

This can be reversed with string-as-multibyte), to change a unibyte string
holding UTF-8 encoded text back into a multibyte string. Note that these
functions are different than string-to-unibyte and string-to-multibyte, which
will attempt a conversion rather than preserving the raw bytes.

The length and buffer-size functions always count characters in multibyte and
bytes in unibyte. Being UTF-8, there are no surrogate pairs to worry about
here. The string-bytes and position-bytes functions return byte information
for both multibyte and unibyte.

To specify a Unicode character in a string literal without using the character
directly, use \uXXXX. The XXXX is the hexadecimal code point for the character
and is always 4 digits long. For characters outside the BMP, which won‚Äôt fit
in four digits, use a capital U with eight digits: \UXXXXXXXX.

#+BEGIN_SRC emacs-lisp
  "\u03C0"
  ;; => "œÄ"

  "\U0001F4A9"
  ;; => "üí©"  (PILE OF POO)
#+END_SRC

Finally, Emacs extends Unicode with 256 additional ‚Äúcharacters‚Äù representing
raw bytes. This allows raw bytes to be embedded distinctly within UTF-8
sequences. For example, it‚Äôs used to distinguish the code point U+0041 from
the raw byte #x41. As far as I can tell, this isn‚Äôt used very often.

* Combining Characters

Some Unicode characters are defined as combining characters. These characters
modify the non-combining character that appears before it, typically with
accents or diacritical marks.

For example, the word ‚Äúna√Øve‚Äù can be written as six characters as "nai\
u0308ve". The fourth character, U+0308 (COMBINING DIAERESIS), is a combining
character that changes the ‚Äúi‚Äù (U+0069 LATIN SMALL LETTER I) into an umlaut
character.

The most commonly accented characters have a code of their own. These are
called precomposed characters. This includes √Ø (U+00EF LATIN SMALL LETTER I
WITH DIAERESIS). This means ‚Äúna√Øve‚Äù can also be written as five characters as
"na\u00EFve".

** Normalization

So what happens when comparing two different representations of the same text?
They‚Äôre not equal.

#+BEGIN_SRC emacs-lisp
  (string= "nai\u0308ve" "na\u00EFve")
  ;; => nil
#+END_SRC

To deal with situations like this, the Unicode standard defines four different
kinds of normalization. The two most important ones are NFC (composition) and
NFD (decomposition). The former uses precomposed characters whenever possible
and the latter breaks them apart. The functions ucs-normalize-NFC-string and
ucs-normalize-NFD-string perform this operation.

Pitfall #1: Proper string comparison requires normalization. It doesn‚Äôt matter
which normalization you use (though NFD should be slightly faster), you just
need to use it consistently. Unfortunately this can get tricky when using
equal to compare complex data structures with multiple strings.

#+BEGIN_SRC emacs-lisp
  (string= (ucs-normalize-NFD-string "nai\u0308ve")
           (ucs-normalize-NFD-string "na\u00EFve"))
  ;; => t
#+END_SRC

Emacs itself fails to do this. It doesn‚Äôt normalize strings before interning
them, which is probably a mistake. This means you can have differently defined
variables and functions with the same canonical name.

#+BEGIN_SRC emacs-lisp
  (eq (intern "nai\u0308ve")
      (intern "na\u00EFve"))
  ;; => nil

  (defun print-r√©sum√© ()
    "NFC-normalized form."
    (print "I'm going to sabotage your team."))

  (defun print-reÃÅsumeÃÅ ()
    "NFD-normalized form."
    (print "I'd be a great asset to your team."))

  (print-r√©sum√©)
  ;; => "I'm going to sabotage your team."
#+END_SRC

** String Width

There are three ways to quantify multibyte text. These are often the same
value, but in some circumstances they can each be different.

  * length: number of characters, including combining characters
  * bytes: number of bytes in its UTF-8 encoding
  * width: number of columns it would occupy in the current buffer

Most of the time, one character is one column (a width of one). Some
characters, like combining characters, consume no columns. Many Asian
characters consume two columns (U+4000, ‰ÄÄ). Tabs consume tab-width columns,
usually 8.

Generally, a string should have the same width regardless of which whether
it‚Äôs NFD or NFC. However, due to bugs and incomplete Unicode support, this
isn‚Äôt strictly true. For example, some combining characters, such as U+20DD ‚Éù,
won‚Äôt combine correctly in Emacs nor in other applications.

Pitfall #2: Always measure text by width, not length, when laying out a buffer
. Width is measured with the string-width function. This comes up when laying
out tables in a buffer. The number of characters that fit in a column depends
on what those characters are.

Fortunately I accidentally got this right in [[http://nullprogram.com/blog/2013/09/04/][Elfeed]] because I used the format
function for layout. The %s directive operates on width, as would be expected.
However, this has the side effect that the output of may format change
depending on the current buffer! Pitfall #3: Be mindful of the current buffer
when using the format function.

#+BEGIN_SRC emacs-lisp
  (let ((tab-width 4))
    (length (format "%.6s" "\t")))
  ;; => 1

  (let ((tab-width 8))
    (length (format "%.6s" "\t")))
  ;; => 0
#+END_SRC

** String Reversal

Say you want to reverse a multibyte string. Simple, right?

#+BEGIN_SRC emacs-lisp
  (defun reverse-string (string)
    (concat (reverse (string-to-list string))))

  (reverse-string "abc")
  ;; => "cba"
#+END_SRC

Wrong! The combining characters will get flipped around to the wrong side of
the character they‚Äôre meant to modify.

#+BEGIN_SRC emacs-lisp
  (reverse-string "nai\u0308ve")
  ;; => "evÃàian"
#+END_SRC

Pitfall #4: [[https://github.com/mathiasbynens/esrever][Reversing Unicode strings is non-trivial]]. The [[http://rosettacode.org/wiki/Reverse_a_string][Rosetta Code]] page is
full of incorrect examples, and [[http://nullprogram.com/blog/2012/11/15/][I‚Äôm personally guilty]] of this, too. The other
day I [[https://github.com/magnars/s.el/pull/58][submitted a patch to s.el]] to correct its s-reverse function for Unicode.
If it‚Äôs accepted, you should never need to worry about this.

** Regular Expressions

Regular expressions operate on code points. This means combining characters
are counted separately and the match may change depending on how characters
are composed. To avoid this, you might want to consider NFC normalization
before performing some kinds of regular expressions.

#+BEGIN_SRC emacs-lisp
  ;; Like string= from before:
  (string-match-p  "na\u00EFve" "nai\u0308ve")
  ;; => nil

  ;; The . only matches part of the composition
  (string-match-p "na.ve" "nai\u0308ve")
  ;; => nil
#+END_SRC

Pitfall #5: Be mindful of combining characters when using regular expressions.
Prefer NFC normalization when dealing with regular expressions.

Another potential problem is ranges, though this is quite uncommon. Ranges of
characters can be expressed in inside brackets, e.g. [a-zA-Z]. If the range
begins or ends with a decomposed combining character you won‚Äôt get the proper
range because its parts are considered separately by the regular expression
engine.

#+BEGIN_SRC emacs-lisp
  (defvar match-weird "[\u00E0-\u00F6]+")

  (string-match-p match-weird "√°√¢√£√§√•")
  ;; => 0  (successful match)

  (string-match-p (ucs-normalize-NFD-string match-weird) "√°√¢√£√§√•")
  ;; => nil
#+END_SRC

It‚Äôs especially important to keep all of this in mind when sanitizing
untrusted input, such as when using Emacs as a web server. An attacker might
use a denormalized or strange grapheme cluster to bypass a filter.

* Interacting with the World

Here‚Äôs a mistake I‚Äôve made twice now. Emacs uses UTF-8 internally, regardless
of whatever encoding the original text came in. 
Pitfall #6: *When working with bytes of text, the counts may be different than the original source of the text*.

For example, HTTP/1.1 introduced persistent connections. Before this, a client
connects to a server and asks for content. The server sends the content and
then closes the connection to signal the end of the data. In HTTP/1.1, when
Connection: close isn‚Äôt specified, the server will instead send a
Content-Length header indicating the length of the content in bytes. The
connection can then be re-used for more requests, or, more importantly,
pipelining requests.

The main problem is that HTTP headers usually have a different encoding than
the content body. Emacs is not prepared to handle multiple encodings from a
single source, so the only correct way to talk HTTP with a network process is
raw. My mistake was allowing Emacs to do the UTF-8 conversion, then measuring
the length of the content in its UTF-8 encoding. This just happens to work
fine about 99.9% of the time since clients tend to speak UTF-8, or something
like it, anyway, but it‚Äôs not correct.

* Further Reading

A lot of this investigation was inspired by JavaScript‚Äôs and other languages‚Äô
Unicode shortcomings.

  * [[http://www.cl.cam.ac.uk/~mgk25/unicode.html][UTF-8 and Unicode FAQ for Unix/Linux]]
  * [[https://speakerdeck.com/mathiasbynens/hacking-with-unicode][Hacking with Unicode]]
  * [[https://github.com/mathiasbynens/jsesc][jsesc]]
  * [[http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#unicode][java.lang.Character Unicode Character Representations]]
  * [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-and-Characters.html][GNU Emacs Lisp Reference Manual: Strings and Characters]]

Comparatively, Emacs Lisp has really great Unicode support. This isn‚Äôt too
surprising considering that it‚Äôs primary purpose is for manipulating text.
