#+URL: http://nullprogram.com/blog/2014/06/13/
#+TITLE: Emacs Unicodeé™·é˜±

GNU Emacsçš„å‘å¸ƒè¦æ¯”Unicodeæ—©7å¹´ã€‚Emacså­˜åœ¨ä»¥åŽæ˜¯åœ¨ç›¸å¯¹è¾ƒæ™šçš„æ—¶å€™æ‰åŠ å…¥äº†å¯¹Unicodeçš„æ”¯æŒï¼Œè¿™æ„å‘³ç€åœ¨Emacsçš„åŽ†å²ä¸­ï¼Œä¸æ”¯æŒUnicodeçš„æ—¶é—´æ®µï¼ˆ16å¹´ï¼‰æ¯”æ”¯æŒUnicodeçš„æ—¶é—´æ®µï¼ˆ14å¹´ï¼‰è¿˜è¦é•¿ã€Œæ³¨ï¼šæ–‡ç« å‘è¡¨äºŽ2014å¹´ã€ã€‚å°½ç®¡å¦‚æ­¤ï¼ŒEmacså¯¹Unicodeçš„æ”¯æŒååˆ†å‡ºè‰²ï¼Œè®©äººæ„Ÿè§‰ä¼¼ä¹Žå®ƒä¸€ç›´éƒ½æ”¯æŒUnicodeã€‚
# Emacsé¦–æ¬¡å‘å¸ƒäºŽ1985å¹´3æœˆ
# Unicodeé¦–æ¬¡å‘å¸ƒäºŽ1992å¹´6æœˆ
ç„¶è€Œ,ç”±äºŽUnicodeçš„ç›®æ ‡æ˜¯è¦æ¶µç›–æ‰€æœ‰å·²çŸ¥çš„äººç±»è¯­è¨€åŠå…¶å„å¼å„æ ·çš„ç»†æžæœ«èŠ‚,ç»“æžœè‡ªç„¶ä¼šå­˜åœ¨ä¸€äº›é™·é˜±å’Œé—®é¢˜ã€‚å¦‚æžœä»…ä½œä¸ºä¸€ä¸ªEmacsä½¿ç”¨è€…çš„è¯ï¼Œä½ å¯èƒ½ä¸å¤ªä¼šå› æ­¤è€Œå—åˆ°å½±å“ã€‚ä½†å¦‚æžœä½œä¸ºä¸€ä¸ªæ‰©å±•ï¼ˆæ’ä»¶ï¼‰çš„å¼€å‘è€…ï¼Œä½ å¾ˆå¯èƒ½ä¼šåœ¨å¤„ç†Emacsçš„stringså’Œbuffersæ—¶é‡åˆ°éº»çƒ¦ï¼Œè¿™ä¸¤ä¸ªéƒ½æ˜¯åŸºäºŽå­—ç¬¦çš„æ•°æ®ç»“æž„ã€‚

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°†åˆ†äº«Elispä¸­Unicodeå¸¦ç»™æˆ‘ä»¬çš„â€œæƒŠå–œâ€ã€‚æˆ‘è‡ªå·±å°±æ›¾é‡åˆ°è¿‡å¥½å‡ ä¸ªï¼Œäº‹å®žä¸Šï¼Œå†™è¿™ç¯‡æ–‡ç« è¿˜è®©æˆ‘åœ¨è‡ªå·±çš„æ‰©å±•ç¨‹åºä¸­å‘çŽ°äº†å¥½å‡ ä¸ªç¼–ç æ–¹é¢çš„å°bugã€‚è¿™äº›ç¼ºé™·éƒ½ä¸æ˜¯Emcasçš„é”™ï¼Œå®ƒä»¬åªæ˜¯è‡ªç„¶è¯­è¨€çš„å¤æ‚æ€§å¯¼è‡´çš„ç»“æžœã€‚

* Unicodeå’Œç¼–ç å€¼ï¼ˆCode Pointï¼‰

é¦–å…ˆï¼Œç½‘ä¸Šæœ‰éžå¸¸å¥½çš„èµ„æ–™æ¥å­¦ä¹ Unicodeï¼Œæˆ‘æŽ¨èä»Ž[[http://www.cl.cam.ac.uk/~mgk25/unicode.html][UTF-8 and Unicode FAQ for Unix/Linux]]å¼€å§‹ã€‚æˆ‘æ²¡æœ‰ç†ç”±åœ¨è¿™é‡Œé‡å¤æ‰€æœ‰çš„ä¿¡æ¯ï¼Œä½†æ˜¯æˆ‘ä¼šå°è¯•å¿«é€Ÿåœ°æ€»ç»“ä¸€ä¸‹ã€‚Unicodeå°†ä¸€ä¸ªç¼–ç å€¼ï¼ˆæ•´æ•°ï¼‰æ˜ å°„åˆ°æŸä¸ªå…·ä½“çš„å­—ç¬¦ï¼Œå¹¶å¸¦ä¸€ä¸ªæ ‡å‡†çš„åå­—ã€‚åœ¨å†™è¿™ç¯‡æ–‡ç« çš„æ—¶å€™Unicodeå®šä¹‰äº†è¶…è¿‡11ä¸‡ä¸ªçš„å­—ç¬¦ã€‚ä¸ºäº†åŽå‘å…¼å®¹æ€§ï¼Œå‰128ä¸ªç¼–ç å€¼æ˜ å°„åˆ°ASCIIç ã€‚è¿™ä¸ªè¶‹åŠ¿ä¹Ÿè¢«å…¶ä»–çš„å­—ç¬¦ç¼–ç æ ‡å‡†æŽ¥å—ï¼Œæ¯”å¦‚Latin-1ã€‚

åœ¨Emacsä¸­ï¼ŒUnicodeå­—ç¬¦ä½¿ç”¨C-x 8 RETï¼ˆinsert-charï¼‰è¾“å…¥åˆ°bufferä¸­ã€‚ä½ æ—¢å¯ä»¥è¾“å…¥æ ‡å‡†çš„å­—ç¬¦åç§°ï¼ˆæ¯”å¦‚ï¼šÏ€æ˜¯â€œGREEK SMALL LETTER PIâ€ï¼‰ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥è¾“å…¥åå…­è¿›åˆ¶çš„ç¼–ç å€¼ã€‚åœ¨Emacsä¹‹å¤–çš„å…¶ä»–åº”ç”¨ç¨‹åºä¸­å¦‚ä½•è¾“å…¥æ˜¯è¦çœ‹æƒ…å†µçš„ï¼Œä½†æ˜¯å°±æˆ‘å…³å¿ƒçš„åº”ç”¨æ¥è¯´C-S-uåŠ ä¸Šåå…­è¿›åˆ¶çš„ç¼–ç å€¼éƒ½æ˜¯å¯ä»¥çš„ã€‚

** ç¼–ç 

Unicodeæ ‡å‡†ä¹Ÿæè¿°äº†å‡ ç§æ–¹æ³•æ¥å°†ç¼–ç å€¼åºåˆ—è½¬æˆå­—èŠ‚åºåˆ—ã€‚å¾ˆæ˜Žæ˜¾ï¼Œ11ä¸‡ä¸ªå­—ç¬¦æ— æ³•ç”¨ä¸€ä¸ªå­—èŠ‚æ¥ç¼–ç ï¼Œæ‰€ä»¥å°±æœ‰äº†å¤šå­—èŠ‚ç¼–ç æ ¼å¼ã€‚æœ€æµè¡Œçš„ä¸¤ç§Unicodeç¼–ç æ ¼å¼åº”è¯¥æ˜¯UTF-8å’ŒUTF-16ã€‚

UTF-8è®¾è®¡ä¹‹åˆå°±æ˜¯è¦åŽå‘å…¼å®¹å·²å­˜åœ¨çš„ASCIIç¼–ç ã€Unixç³»ç»Ÿä»¥åŠCè¯­è¨€APIï¼ˆä»¥nullä½œä¸ºç»ˆæ­¢ç¬¦çš„Cå­—ç¬¦ä¸²ï¼‰ã€‚å‰128ä¸ªç¼–ç å€¼ç›´æŽ¥ç¼–ç ä¸ºå•å­—èŠ‚ï¼Œå…¶ä»–å­—ç¬¦ç”¨2åˆ°6çš„å­—èŠ‚æ¥ç¼–ç ï¼Œæ‰€æœ‰å­—èŠ‚çš„æœ€é«˜æ¯”ç‰¹è®¾ç½®ä¸º1ï¼Œè¿™æ ·æ‰€æœ‰å¤šå­—èŠ‚çš„å­—ç¬¦éƒ½ä¸ä¼šè¢«è§£é‡Šä¸ºASCIIå­—ç¬¦ï¼Œä¹Ÿä¸ä¼šå­˜åœ¨nullï¼ˆ0ï¼‰ã€‚è¿™æ ·Cè¯­è¨€å†™çš„ç¨‹åºå’ŒAPIå°±èƒ½å¤Ÿä¸æ”¹å˜æˆ–è€…åšç¨å¾®è°ƒæ•´å°±èƒ½å¤„ç†UTF-8çš„å­—ç¬¦ä¸²äº†ã€‚æœ€é‡è¦çš„æ˜¯ï¼Œæ¯ä¸€ä¸ªASCIIç ç¼–ç çš„æ–‡ä»¶è‡ªåŠ¨å¯ä»¥è½¬æ¢ä¸ºUTF-8ç¼–ç çš„æ–‡ä»¶ã€‚

UTF-16ç”¨2ä¸ªå­—èŠ‚æ¥ç¼–ç åŸºæœ¬å¤šæ–‡ç§å¹³é¢ï¼ˆç¬¬é›¶å¹³é¢ï¼ŒBasic Multilingual Plane - BMPï¼‰ä¸­çš„å­—ç¬¦ï¼Œç”šè‡³åŽŸæœ¬çš„ASCIIå­—ç¬¦ä¹Ÿç”¨2ä¸ªå­—èŠ‚ï¼ˆ16æ¯”ç‰¹ï¼‰ã€‚ç¬¬é›¶å¹³é¢åŸºæœ¬ä¸Šæ¶µç›–äº†æ‰€æœ‰çŽ°ä»£è¯­è¨€ä¸­å®žé™…ä½¿ç”¨åˆ°çš„æ‰€æœ‰å­—ç¬¦ã€‚ç„¶è€Œ,UTF-16å´ä¸åŒ…æ‹¬è¾…åŠ©ï¼ˆæ˜Ÿä½“ï¼‰å¹³é¢ä¸­é‡è¦çš„ä¾‹å¦‚[[http://www.fileformat.info/info/unicode/char/1f379/index.htm][TROPICAL DRINK]]æˆ–è€…[[http://www.fileformat.info/info/unicode/char/1F4A9/index.htm][PILE OF POO]]å­—ç¬¦ã€‚å¦‚æžœä½ éœ€è¦åœ¨UTF-16ä¸­ç”¨è¿™äº›å­—ç¬¦å°†å‡ºçŽ°é—®é¢˜ï¼šè¶…è¿‡ç¬¬é›¶å¹³é¢çš„å­—ç¬¦ä¸èƒ½è¢«æ”¾åœ¨2ä¸ªå­—èŠ‚ä¸­ã€‚ä¸ºäº†èƒ½å®¹çº³è¿™äº›å­—ç¬¦ï¼ŒUTF-16ä½¿ç”¨ä»£ç†å¯¹ï¼ˆsurrogate pairsï¼‰ï¼šè¿™äº›å­—ç¬¦ä¼šç”¨ä¸€å¯¹2å­—èŠ‚å•å…ƒæ¥ç¼–ç ã€‚

ç”±äºŽæœ€åŽä¸€ç‚¹, UTF-16ç›¸å¯¹äºŽUTF-8æ²¡æœ‰å®žç”¨ä¸Šçš„ä¼˜åŠ¿ã€‚å®ƒçš„[[http://www.utf8everywhere.org/][å­˜åœ¨å¯èƒ½æ˜¯ä¸€ä¸ªå·¨å¤§çš„é”™è¯¯]]ã€‚ç”±äºŽä»£ç†å¯¹çš„å­˜åœ¨ï¼Œä½ æ— æ³•ç”¨æ’å®šæ—¶é—´ç®—æ³•åŽ»æŸ¥æ‰¾ï¼Œè€Œä¸”ä¸èƒ½åŽå‘å…¼å®¹ä¹Ÿä¸èƒ½å­˜å‚¨åœ¨ä»¥nullç»“å°¾çš„å­—ç¬¦ä¸²ä¸­ã€‚åœ¨Javaå’ŒJavaScriptä¸­ï¼Œå®ƒä¼šå¯¼è‡´ä¸€äº›å­—ç¬¦ä¸²â€œé•¿åº¦â€å’Œå­—ç¬¦ã€ç¼–ç å€¼ç”šè‡³å­—èŠ‚æ•°ä¸ä¸€è‡³çš„çª˜å¢ƒã€‚æœ€ç³Ÿç³•çš„æ˜¯ï¼Œå®ƒä¼šå¯¼è‡´[[https://speakerdeck.com/mathiasbynens/hacking-with-unicode?slide=114][ä¸¥é‡çš„å®‰å…¨éšæ‚£]]ã€‚æ–°çš„åº”ç”¨ç¨‹åºåº”è¯¥å°½å¯èƒ½åœ°é¿å…è¿™äº›é—®é¢˜ã€‚

* Emacså’ŒUTF-8

*åœ¨Emacså†…éƒ¨æ‰€æœ‰çš„æ–‡æœ¬éƒ½ç”¨UTF-8æ ¼å¼å­˜å‚¨*. This was an excellent choice! When
text leaves Emacs, such as writing to a file or to a process, Emacs
automatically converts it to the coding system configured for that particular
file or process. When it accepts text from a file or process, it either
converts it to UTF-8 or preserves it as raw bytes.

There are two modes for this in Emacs: unibyte and multibyte. Unibyte strings/
buffers are just raw bytes. They have constant access O(1) time but can only
hold single-byte values. The [[http://nullprogram.com/blog/2014/01/04/][byte-code compiler outputs unibyte strings]].

Multibyte strings/buffers hold UTF-8 encoded code points. Character access is
O(n) because the string/buffer has to be scanned to count characters.

The actual encoding is rarely relevant because thereâ€™s little way (and need)
to access it directly. Emacs automatically converts text as needed when it
leaves Emacs and arrives in Emacs, so thereâ€™s no need to know the internal
encoding. If you really want to see it anyway, you can use string-as-unibyte
to get a copy of a string with the exact same bytes, but as a byte-string.

#+BEGIN_SRC emacs-lisp
  (string-as-unibyte "Ï€")
  ;; => "\317\200"
#+END_SRC

This can be reversed with string-as-multibyte), to change a unibyte string
holding UTF-8 encoded text back into a multibyte string. Note that these
functions are different than string-to-unibyte and string-to-multibyte, which
will attempt a conversion rather than preserving the raw bytes.

The length and buffer-size functions always count characters in multibyte and
bytes in unibyte. Being UTF-8, there are no surrogate pairs to worry about
here. The string-bytes and position-bytes functions return byte information
for both multibyte and unibyte.

To specify a Unicode character in a string literal without using the character
directly, use \uXXXX. The XXXX is the hexadecimal code point for the character
and is always 4 digits long. For characters outside the BMP, which wonâ€™t fit
in four digits, use a capital U with eight digits: \UXXXXXXXX.

#+BEGIN_SRC emacs-lisp
  "\u03C0"
  ;; => "Ï€"

  "\U0001F4A9"
  ;; => "ðŸ’©"  (PILE OF POO)
#+END_SRC

Finally, Emacs extends Unicode with 256 additional â€œcharactersâ€ representing
raw bytes. This allows raw bytes to be embedded distinctly within UTF-8
sequences. For example, itâ€™s used to distinguish the code point U+0041 from
the raw byte #x41. As far as I can tell, this isnâ€™t used very often.

* Combining Characters

Some Unicode characters are defined as combining characters. These characters
modify the non-combining character that appears before it, typically with
accents or diacritical marks.

For example, the word â€œnaÃ¯veâ€ can be written as six characters as "nai\
u0308ve". The fourth character, U+0308 (COMBINING DIAERESIS), is a combining
character that changes the â€œiâ€ (U+0069 LATIN SMALL LETTER I) into an umlaut
character.

The most commonly accented characters have a code of their own. These are
called precomposed characters. This includes Ã¯ (U+00EF LATIN SMALL LETTER I
WITH DIAERESIS). This means â€œnaÃ¯veâ€ can also be written as five characters as
"na\u00EFve".

** Normalization

So what happens when comparing two different representations of the same text?
Theyâ€™re not equal.

#+BEGIN_SRC emacs-lisp
  (string= "nai\u0308ve" "na\u00EFve")
  ;; => nil
#+END_SRC

To deal with situations like this, the Unicode standard defines four different
kinds of normalization. The two most important ones are NFC (composition) and
NFD (decomposition). The former uses precomposed characters whenever possible
and the latter breaks them apart. The functions ucs-normalize-NFC-string and
ucs-normalize-NFD-string perform this operation.

Pitfall #1: Proper string comparison requires normalization. It doesnâ€™t matter
which normalization you use (though NFD should be slightly faster), you just
need to use it consistently. Unfortunately this can get tricky when using
equal to compare complex data structures with multiple strings.

#+BEGIN_SRC emacs-lisp
  (string= (ucs-normalize-NFD-string "nai\u0308ve")
           (ucs-normalize-NFD-string "na\u00EFve"))
  ;; => t
#+END_SRC

Emacs itself fails to do this. It doesnâ€™t normalize strings before interning
them, which is probably a mistake. This means you can have differently defined
variables and functions with the same canonical name.

#+BEGIN_SRC emacs-lisp
  (eq (intern "nai\u0308ve")
      (intern "na\u00EFve"))
  ;; => nil

  (defun print-rÃ©sumÃ© ()
    "NFC-normalized form."
    (print "I'm going to sabotage your team."))

  (defun print-reÌsumeÌ ()
    "NFD-normalized form."
    (print "I'd be a great asset to your team."))

  (print-rÃ©sumÃ©)
  ;; => "I'm going to sabotage your team."
#+END_SRC

** String Width

There are three ways to quantify multibyte text. These are often the same
value, but in some circumstances they can each be different.

  * length: number of characters, including combining characters
  * bytes: number of bytes in its UTF-8 encoding
  * width: number of columns it would occupy in the current buffer

Most of the time, one character is one column (a width of one). Some
characters, like combining characters, consume no columns. Many Asian
characters consume two columns (U+4000, ä€€). Tabs consume tab-width columns,
usually 8.

Generally, a string should have the same width regardless of which whether
itâ€™s NFD or NFC. However, due to bugs and incomplete Unicode support, this
isnâ€™t strictly true. For example, some combining characters, such as U+20DD âƒ,
wonâ€™t combine correctly in Emacs nor in other applications.

Pitfall #2: Always measure text by width, not length, when laying out a buffer
. Width is measured with the string-width function. This comes up when laying
out tables in a buffer. The number of characters that fit in a column depends
on what those characters are.

Fortunately I accidentally got this right in [[http://nullprogram.com/blog/2013/09/04/][Elfeed]] because I used the format
function for layout. The %s directive operates on width, as would be expected.
However, this has the side effect that the output of may format change
depending on the current buffer! Pitfall #3: Be mindful of the current buffer
when using the format function.

#+BEGIN_SRC emacs-lisp
  (let ((tab-width 4))
    (length (format "%.6s" "\t")))
  ;; => 1

  (let ((tab-width 8))
    (length (format "%.6s" "\t")))
  ;; => 0
#+END_SRC

** String Reversal

Say you want to reverse a multibyte string. Simple, right?

#+BEGIN_SRC emacs-lisp
  (defun reverse-string (string)
    (concat (reverse (string-to-list string))))

  (reverse-string "abc")
  ;; => "cba"
#+END_SRC

Wrong! The combining characters will get flipped around to the wrong side of
the character theyâ€™re meant to modify.

#+BEGIN_SRC emacs-lisp
  (reverse-string "nai\u0308ve")
  ;; => "evÌˆian"
#+END_SRC

Pitfall #4: [[https://github.com/mathiasbynens/esrever][Reversing Unicode strings is non-trivial]]. The [[http://rosettacode.org/wiki/Reverse_a_string][Rosetta Code]] page is
full of incorrect examples, and [[http://nullprogram.com/blog/2012/11/15/][Iâ€™m personally guilty]] of this, too. The other
day I [[https://github.com/magnars/s.el/pull/58][submitted a patch to s.el]] to correct its s-reverse function for Unicode.
If itâ€™s accepted, you should never need to worry about this.

** Regular Expressions

Regular expressions operate on code points. This means combining characters
are counted separately and the match may change depending on how characters
are composed. To avoid this, you might want to consider NFC normalization
before performing some kinds of regular expressions.

#+BEGIN_SRC emacs-lisp
  ;; Like string= from before:
  (string-match-p  "na\u00EFve" "nai\u0308ve")
  ;; => nil

  ;; The . only matches part of the composition
  (string-match-p "na.ve" "nai\u0308ve")
  ;; => nil
#+END_SRC

Pitfall #5: Be mindful of combining characters when using regular expressions.
Prefer NFC normalization when dealing with regular expressions.

Another potential problem is ranges, though this is quite uncommon. Ranges of
characters can be expressed in inside brackets, e.g. [a-zA-Z]. If the range
begins or ends with a decomposed combining character you wonâ€™t get the proper
range because its parts are considered separately by the regular expression
engine.

#+BEGIN_SRC emacs-lisp
  (defvar match-weird "[\u00E0-\u00F6]+")

  (string-match-p match-weird "Ã¡Ã¢Ã£Ã¤Ã¥")
  ;; => 0  (successful match)

  (string-match-p (ucs-normalize-NFD-string match-weird) "Ã¡Ã¢Ã£Ã¤Ã¥")
  ;; => nil
#+END_SRC

Itâ€™s especially important to keep all of this in mind when sanitizing
untrusted input, such as when using Emacs as a web server. An attacker might
use a denormalized or strange grapheme cluster to bypass a filter.

* Interacting with the World

Hereâ€™s a mistake Iâ€™ve made twice now. Emacs uses UTF-8 internally, regardless
of whatever encoding the original text came in. 
Pitfall #6: *When working with bytes of text, the counts may be different than the original source of the text*.

For example, HTTP/1.1 introduced persistent connections. Before this, a client
connects to a server and asks for content. The server sends the content and
then closes the connection to signal the end of the data. In HTTP/1.1, when
Connection: close isnâ€™t specified, the server will instead send a
Content-Length header indicating the length of the content in bytes. The
connection can then be re-used for more requests, or, more importantly,
pipelining requests.

The main problem is that HTTP headers usually have a different encoding than
the content body. Emacs is not prepared to handle multiple encodings from a
single source, so the only correct way to talk HTTP with a network process is
raw. My mistake was allowing Emacs to do the UTF-8 conversion, then measuring
the length of the content in its UTF-8 encoding. This just happens to work
fine about 99.9% of the time since clients tend to speak UTF-8, or something
like it, anyway, but itâ€™s not correct.

* Further Reading

A lot of this investigation was inspired by JavaScriptâ€™s and other languagesâ€™
Unicode shortcomings.

  * [[http://www.cl.cam.ac.uk/~mgk25/unicode.html][UTF-8 and Unicode FAQ for Unix/Linux]]
  * [[https://speakerdeck.com/mathiasbynens/hacking-with-unicode][Hacking with Unicode]]
  * [[https://github.com/mathiasbynens/jsesc][jsesc]]
  * [[http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#unicode][java.lang.Character Unicode Character Representations]]
  * [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Strings-and-Characters.html][GNU Emacs Lisp Reference Manual: Strings and Characters]]

Comparatively, Emacs Lisp has really great Unicode support. This isnâ€™t too
surprising considering that itâ€™s primary purpose is for manipulating text.
