* 组合字符（Combining Characters）

Some Unicode characters are defined as combining characters. These characters
modify the non-combining character that appears before it, typically with
accents or diacritical marks.

For example, the word “naïve” can be written as six characters as "nai\
u0308ve". The fourth character, U+0308 (COMBINING DIAERESIS), is a combining
character that changes the “i” (U+0069 LATIN SMALL LETTER I) into an umlaut
character.

The most commonly accented characters have a code of their own. These are
called precomposed characters. This includes ï (U+00EF LATIN SMALL LETTER I
WITH DIAERESIS). This means “naïve” can also be written as five characters as
"na\u00EFve".

** Normalization

So what happens when comparing two different representations of the same text?
They’re not equal.

#+BEGIN_SRC emacs-lisp
  (string= "nai\u0308ve" "na\u00EFve")
  ;; => nil
#+END_SRC

To deal with situations like this, the Unicode standard defines four different
kinds of normalization. The two most important ones are NFC (composition) and
NFD (decomposition). The former uses precomposed characters whenever possible
and the latter breaks them apart. The functions ucs-normalize-NFC-string and
ucs-normalize-NFD-string perform this operation.

Pitfall #1: Proper string comparison requires normalization. It doesn’t matter
which normalization you use (though NFD should be slightly faster), you just
need to use it consistently. Unfortunately this can get tricky when using
equal to compare complex data structures with multiple strings.

#+BEGIN_SRC emacs-lisp
  (string= (ucs-normalize-NFD-string "nai\u0308ve")
           (ucs-normalize-NFD-string "na\u00EFve"))
  ;; => t
#+END_SRC

Emacs itself fails to do this. It doesn’t normalize strings before interning
them, which is probably a mistake. This means you can have differently defined
variables and functions with the same canonical name.

#+BEGIN_SRC emacs-lisp
  (eq (intern "nai\u0308ve")
      (intern "na\u00EFve"))
  ;; => nil

  (defun print-résumé ()
    "NFC-normalized form."
    (print "I'm going to sabotage your team."))

  (defun print-résumé ()
    "NFD-normalized form."
    (print "I'd be a great asset to your team."))

  (print-résumé)
  ;; => "I'm going to sabotage your team."
#+END_SRC

** String Width

There are three ways to quantify multibyte text. These are often the same
value, but in some circumstances they can each be different.

  * length: number of characters, including combining characters
  * bytes: number of bytes in its UTF-8 encoding
  * width: number of columns it would occupy in the current buffer

Most of the time, one character is one column (a width of one). Some
characters, like combining characters, consume no columns. Many Asian
characters consume two columns (U+4000, 䀀). Tabs consume tab-width columns,
usually 8.

Generally, a string should have the same width regardless of which whether
it’s NFD or NFC. However, due to bugs and incomplete Unicode support, this
isn’t strictly true. For example, some combining characters, such as U+20DD ⃝,
won’t combine correctly in Emacs nor in other applications.

Pitfall #2: Always measure text by width, not length, when laying out a buffer
. Width is measured with the string-width function. This comes up when laying
out tables in a buffer. The number of characters that fit in a column depends
on what those characters are.

Fortunately I accidentally got this right in [[http://nullprogram.com/blog/2013/09/04/][Elfeed]] because I used the format
function for layout. The %s directive operates on width, as would be expected.
However, this has the side effect that the output of may format change
depending on the current buffer! Pitfall #3: Be mindful of the current buffer
when using the format function.

#+BEGIN_SRC emacs-lisp
  (let ((tab-width 4))
    (length (format "%.6s" "\t")))
  ;; => 1

  (let ((tab-width 8))
    (length (format "%.6s" "\t")))
  ;; => 0
#+END_SRC

** String Reversal

Say you want to reverse a multibyte string. Simple, right?

#+BEGIN_SRC emacs-lisp
  (defun reverse-string (string)
    (concat (reverse (string-to-list string))))

  (reverse-string "abc")
  ;; => "cba"
#+END_SRC

Wrong! The combining characters will get flipped around to the wrong side of
the character they’re meant to modify.

#+BEGIN_SRC emacs-lisp
  (reverse-string "nai\u0308ve")
  ;; => "ev̈ian"
#+END_SRC

Pitfall #4: [[https://github.com/mathiasbynens/esrever][Reversing Unicode strings is non-trivial]]. The [[http://rosettacode.org/wiki/Reverse_a_string][Rosetta Code]] page is
full of incorrect examples, and [[http://nullprogram.com/blog/2012/11/15/][I’m personally guilty]] of this, too. The other
day I [[https://github.com/magnars/s.el/pull/58][submitted a patch to s.el]] to correct its s-reverse function for Unicode.
If it’s accepted, you should never need to worry about this.

** Regular Expressions

Regular expressions operate on code points. This means combining characters
are counted separately and the match may change depending on how characters
are composed. To avoid this, you might want to consider NFC normalization
before performing some kinds of regular expressions.

#+BEGIN_SRC emacs-lisp
  ;; Like string= from before:
  (string-match-p  "na\u00EFve" "nai\u0308ve")
  ;; => nil

  ;; The . only matches part of the composition
  (string-match-p "na.ve" "nai\u0308ve")
  ;; => nil
#+END_SRC

Pitfall #5: Be mindful of combining characters when using regular expressions.
Prefer NFC normalization when dealing with regular expressions.

Another potential problem is ranges, though this is quite uncommon. Ranges of
characters can be expressed in inside brackets, e.g. [a-zA-Z]. If the range
begins or ends with a decomposed combining character you won’t get the proper
range because its parts are considered separately by the regular expression
engine.

#+BEGIN_SRC emacs-lisp
  (defvar match-weird "[\u00E0-\u00F6]+")

  (string-match-p match-weird "áâãäå")
  ;; => 0  (successful match)

  (string-match-p (ucs-normalize-NFD-string match-weird) "áâãäå")
  ;; => nil
#+END_SRC

It’s especially important to keep all of this in mind when sanitizing
untrusted input, such as when using Emacs as a web server. An attacker might
use a denormalized or strange grapheme cluster to bypass a filter.
